# 泛型

## 什么是泛型？泛型的作用

> 泛型就是参数化类型。就是将具体的类型参数化，类似方法中的变量参数，类型也定义为参数形式（类型形参）。使用的时候传入具体参数（类型实参）。这种参数类型可以用在类、接口跟方法中，分别被称为泛型类，泛型接口、泛型方法。
>
> 例如：`GenericClass<T>`

常用泛型类型变量：

```shell
E：元素(Element)，多用于java集合框架。
K：关键字(Key)
N：数字(Number)
T：类型(Type)
V：值(Value)
```

例如常用的`ArrayList`类：

```java
ArrayList list = new ArrayList();
list.add(1);
list.add("a");
list.add(true);

for(Object o : list) {
    String s = (String)o;  
}
```

如上面这种情况，很明显会发生类型转换异常。在这种情况下就可以使用泛型。

```java
ArrayList<String> strList = new ArrayList<String>();
strList.add("a");
strList.add("b");

for(String s : strList) {
    System.out.println(s);
}
```

这种类型的`List`会在定义的时候就限制类型，明确`List`中保存的数据类型，编译器就会在编译阶段帮我们发现问题。

泛型只在代码编译器有效，如下面代码：

```java
private static void test1() {
    ArrayList<String> strList = new ArrayList<>();
    ArrayList<Integer> intList = new ArrayList<>();
    System.out.println(strList.getClass() == intList.getClass());   //true
}
```

可以看到尽管`strList`跟`intList`使用了不同的泛型，但是它们其实还是同一类型的对象。

这是因为`Java`中是通过类型擦拭实现泛型的，虚拟机对于泛型其实是一无所知的，所有的泛型都是给编译器看的。编译器内部会把所有的类型形参看成是`Object`，再根据类型实参来对数据进行安全的强制转换。例如下面这段代码：

```java
public static void main(String[] args) {
    ArrayList<String> stringList = new ArrayList<>();
    stringList.add("a");

    String s = stringList.get(0);
}
```

通过`javap -c class文件`之后得到：

```java
public static void main(java.lang.String[]);
   Code:
      0: new           #2                  // class java/util/ArrayList
      3: dup
      4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
      7: astore_1
      8: aload_1
      9: ldc           #4                  // String a
     11: invokevirtual #5                  // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z
     14: pop
     15: aload_1
     16: iconst_0
     17: invokevirtual #6                  // Method java/util/ArrayList.get:(I)Ljava/lang/Object;
     20: checkcast     #7                  // class java/lang/String
     23: astore_2
     24: return
}
```

可以明显的看到，虚拟机看到的最初创建的数组只是一个普通的`ArrayList`，之后取出的时候用了强制类型转换将其转为`String`类型。

## 编写泛型

```java
public class SimpleTypeGenerosity<T> {
    private T first;
    private T second;

    public SimpleTypeGenerosity(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }


    public T getSecond() {
        return second;
    }

    public static <T> SimpleTypeGenerosity<T> create(T first, T second) {
        return new SimpleTypeGenerosity<T>(first, second);
    }

}
```

如上面示例，编写泛型方法只需要在方法名后面\<T\>声明，再把特定的类型替换成声明的T就可以了。

泛型类型\<T\>不能直接用于静态方法，使用的时候需要在`static`修饰符后面加一个\<T\>，实际上静态方法中的类型`T`跟类中声明的`T`已经没有任何关系了。

泛型有时候会定义多种类型，比如`Map`。下面是一个自定义两种泛型的例子：

```java
public class DifferentTypeGenerosity<K, V> {
    private K key;
    private V value;

    public DifferentTypeGenerosity(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public void setKey(K key) {
        this.key = key;
    }

    public V getValue() {
        return value;
    }

    public void setValue(V value) {
        this.value = value;
    }
}
```

对于这种泛型类，我们在使用的时候需要指定两个类，这两个类可以是相同的、也可以是不同的。

```java
DifferentTypeGenerosity<String, String> strGenerosity = new DifferentTypeGenerosity<>();
DifferentTypeGenerosity<Integer, String> intGenerosity = new DifferentTypeGenerosity<>();
```



